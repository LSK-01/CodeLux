{
  "version": 3,
  "sources": ["../../svelte/motion/index.mjs"],
  "sourcesContent": ["import { writable } from '../store/index.mjs';\r\nimport { now, loop, assign } from '../internal/index.mjs';\r\nimport { linear } from '../easing/index.mjs';\r\n\r\nfunction is_date(obj) {\r\n    return Object.prototype.toString.call(obj) === '[object Date]';\r\n}\r\n\r\nfunction tick_spring(ctx, last_value, current_value, target_value) {\r\n    if (typeof current_value === 'number' || is_date(current_value)) {\r\n        // @ts-ignore\r\n        const delta = target_value - current_value;\r\n        // @ts-ignore\r\n        const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0\r\n        const spring = ctx.opts.stiffness * delta;\r\n        const damper = ctx.opts.damping * velocity;\r\n        const acceleration = (spring - damper) * ctx.inv_mass;\r\n        const d = (velocity + acceleration) * ctx.dt;\r\n        if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {\r\n            return target_value; // settled\r\n        }\r\n        else {\r\n            ctx.settled = false; // signal loop to keep ticking\r\n            // @ts-ignore\r\n            return is_date(current_value) ?\r\n                new Date(current_value.getTime() + d) : current_value + d;\r\n        }\r\n    }\r\n    else if (Array.isArray(current_value)) {\r\n        // @ts-ignore\r\n        return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));\r\n    }\r\n    else if (typeof current_value === 'object') {\r\n        const next_value = {};\r\n        for (const k in current_value) {\r\n            // @ts-ignore\r\n            next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);\r\n        }\r\n        // @ts-ignore\r\n        return next_value;\r\n    }\r\n    else {\r\n        throw new Error(`Cannot spring ${typeof current_value} values`);\r\n    }\r\n}\r\nfunction spring(value, opts = {}) {\r\n    const store = writable(value);\r\n    const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;\r\n    let last_time;\r\n    let task;\r\n    let current_token;\r\n    let last_value = value;\r\n    let target_value = value;\r\n    let inv_mass = 1;\r\n    let inv_mass_recovery_rate = 0;\r\n    let cancel_task = false;\r\n    function set(new_value, opts = {}) {\r\n        target_value = new_value;\r\n        const token = current_token = {};\r\n        if (value == null || opts.hard || (spring.stiffness >= 1 && spring.damping >= 1)) {\r\n            cancel_task = true; // cancel any running animation\r\n            last_time = now();\r\n            last_value = new_value;\r\n            store.set(value = target_value);\r\n            return Promise.resolve();\r\n        }\r\n        else if (opts.soft) {\r\n            const rate = opts.soft === true ? .5 : +opts.soft;\r\n            inv_mass_recovery_rate = 1 / (rate * 60);\r\n            inv_mass = 0; // infinite mass, unaffected by spring forces\r\n        }\r\n        if (!task) {\r\n            last_time = now();\r\n            cancel_task = false;\r\n            task = loop(now => {\r\n                if (cancel_task) {\r\n                    cancel_task = false;\r\n                    task = null;\r\n                    return false;\r\n                }\r\n                inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);\r\n                const ctx = {\r\n                    inv_mass,\r\n                    opts: spring,\r\n                    settled: true,\r\n                    dt: (now - last_time) * 60 / 1000\r\n                };\r\n                const next_value = tick_spring(ctx, last_value, value, target_value);\r\n                last_time = now;\r\n                last_value = value;\r\n                store.set(value = next_value);\r\n                if (ctx.settled) {\r\n                    task = null;\r\n                }\r\n                return !ctx.settled;\r\n            });\r\n        }\r\n        return new Promise(fulfil => {\r\n            task.promise.then(() => {\r\n                if (token === current_token)\r\n                    fulfil();\r\n            });\r\n        });\r\n    }\r\n    const spring = {\r\n        set,\r\n        update: (fn, opts) => set(fn(target_value, value), opts),\r\n        subscribe: store.subscribe,\r\n        stiffness,\r\n        damping,\r\n        precision\r\n    };\r\n    return spring;\r\n}\r\n\r\nfunction get_interpolator(a, b) {\r\n    if (a === b || a !== a)\r\n        return () => a;\r\n    const type = typeof a;\r\n    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {\r\n        throw new Error('Cannot interpolate values of different type');\r\n    }\r\n    if (Array.isArray(a)) {\r\n        const arr = b.map((bi, i) => {\r\n            return get_interpolator(a[i], bi);\r\n        });\r\n        return t => arr.map(fn => fn(t));\r\n    }\r\n    if (type === 'object') {\r\n        if (!a || !b)\r\n            throw new Error('Object cannot be null');\r\n        if (is_date(a) && is_date(b)) {\r\n            a = a.getTime();\r\n            b = b.getTime();\r\n            const delta = b - a;\r\n            return t => new Date(a + t * delta);\r\n        }\r\n        const keys = Object.keys(b);\r\n        const interpolators = {};\r\n        keys.forEach(key => {\r\n            interpolators[key] = get_interpolator(a[key], b[key]);\r\n        });\r\n        return t => {\r\n            const result = {};\r\n            keys.forEach(key => {\r\n                result[key] = interpolators[key](t);\r\n            });\r\n            return result;\r\n        };\r\n    }\r\n    if (type === 'number') {\r\n        const delta = b - a;\r\n        return t => a + t * delta;\r\n    }\r\n    throw new Error(`Cannot interpolate ${type} values`);\r\n}\r\nfunction tweened(value, defaults = {}) {\r\n    const store = writable(value);\r\n    let task;\r\n    let target_value = value;\r\n    function set(new_value, opts) {\r\n        if (value == null) {\r\n            store.set(value = new_value);\r\n            return Promise.resolve();\r\n        }\r\n        target_value = new_value;\r\n        let previous_task = task;\r\n        let started = false;\r\n        let { delay = 0, duration = 400, easing = linear, interpolate = get_interpolator } = assign(assign({}, defaults), opts);\r\n        if (duration === 0) {\r\n            if (previous_task) {\r\n                previous_task.abort();\r\n                previous_task = null;\r\n            }\r\n            store.set(value = target_value);\r\n            return Promise.resolve();\r\n        }\r\n        const start = now() + delay;\r\n        let fn;\r\n        task = loop(now => {\r\n            if (now < start)\r\n                return true;\r\n            if (!started) {\r\n                fn = interpolate(value, new_value);\r\n                if (typeof duration === 'function')\r\n                    duration = duration(value, new_value);\r\n                started = true;\r\n            }\r\n            if (previous_task) {\r\n                previous_task.abort();\r\n                previous_task = null;\r\n            }\r\n            const elapsed = now - start;\r\n            if (elapsed > duration) {\r\n                store.set(value = new_value);\r\n                return false;\r\n            }\r\n            // @ts-ignore\r\n            store.set(value = fn(easing(elapsed / duration)));\r\n            return true;\r\n        });\r\n        return task.promise;\r\n    }\r\n    return {\r\n        set,\r\n        update: (fn, opts) => set(fn(target_value, value), opts),\r\n        subscribe: store.subscribe\r\n    };\r\n}\r\n\r\nexport { spring, tweened };\r\n"],
  "mappings": "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",
  "names": ["spring", "opts", "now"]
}
